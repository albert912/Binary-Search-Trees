Algorithm

beginning condition ----> if(start>end) return null;

---

let mid = start + Math.floor((end - start) / 2);

---

let root = new Node(arr[mid]);

---

// Recursively construct the left subtree using the left half of the array
root.left = sortedArrayToBSTRecur(arr, start, mid - 1);



mid-1 means the end value for the left subtree

---

// Recursively construct the right subtree using the right half of the array

root.right = sortedArrayToBSTRecur(arr, mid + 1, end);

---

return root; // Return the root of the current subtree
}

---

function sortedArrayToBST(arr) {
    return sortedArrayToBSTRecur(arr, 0, arr.length - 1);
}

---

// Function to print the tree in pre-order traversal (Root → Left → Right)
function preOrder(root) {
    if (root === null) return; // Base case: if tree is empty, stop
    console.log(root.data); // Print the current node's value
    preOrder(root.left); // Recursively print the left subtree
    preOrder(root.right); // Recursively print the right subtree
}



---

// Example: Convert sorted array to BST
const arr = [1, 2, 3, 4]; // Input sorted array
const root = sortedArrayToBST(arr); // Create BST
preOrder(root); // 


---

end= array.length -1
----

Algorithm Example Steps

1. Initialize start = 0, 
   end=array.length-1
   mid =(start+end)/2

2. Create a tree node with mid 
   as root(lets call it A).

3. Recursively do steps 4 and 5:

4. Calculate mid of left subarray
and make it root of left subree of A.

5. Calculate mid of right subarray 
and make it root of right subtree of A.

---

Tips from mergesort



  let mid = Math.floor((start+end)/2);
    //sort left side


    mergeSort(arr, start, mid);
    //sort right side


    mergeSort(arr, mid+1, end);
    //merge sorted arrays

    merge(arr, start, mid, end);
    
    ---

  const leftSize = mid - start + 1;
  const rightSize = end - mid;

-----